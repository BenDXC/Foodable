name: Deploy

on:
  # Deploy workflow is triggered by:
  # 1. Manual dispatch for staging/production
  # 2. Called by release workflow for production releases
  # NOTE: Removed tag trigger to avoid conflicts with release.yml
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: string
      version:
        description: 'Version to deploy'
        required: false
        type: string

jobs:
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      version: ${{ steps.set-version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event.inputs.environment }}" != "" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/tags/v"* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Set version
        id: set-version
        run: |
          if [[ "${{ github.ref }}" == "refs/tags/"* ]]; then
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "version=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  build-frontend:
    name: Build Frontend for Deployment
    needs: prepare
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        working-directory: frontend
        run: npm install

      - name: Build frontend
        working-directory: frontend
        run: npm run build
        env:
          NODE_ENV: production
          VITE_API_BASE_URL: ${{ secrets.API_URL }}

      - name: Upload frontend build
        uses: actions/upload-artifact@v6
        with:
          name: frontend-build
          path: frontend/dist
          retention-days: 7

  build-backend:
    name: Build Backend for Deployment
    needs: prepare
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        working-directory: backend
        run: npm install

      - name: Build backend
        working-directory: backend
        run: npm run build

      - name: Install production dependencies only
        working-directory: backend
        run: |
          rm -rf node_modules
          npm install --omit=dev

      - name: Upload backend build
        uses: actions/upload-artifact@v6
        with:
          name: backend-build
          path: |
            backend/dist
            backend/node_modules
            backend/package.json
          retention-days: 7

  deploy-frontend:
    name: Deploy Frontend to ${{ needs.prepare.outputs.environment }}
    needs: [prepare, build-frontend]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment:
      name: ${{ needs.prepare.outputs.environment }}-frontend
      url: ${{ steps.deploy.outputs.url }}
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
      NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}

    steps:
      - name: Download frontend build
        uses: actions/download-artifact@v7
        with:
          name: frontend-build
          path: frontend/dist

      - name: Deploy to Vercel (if configured)
        id: deploy
        if: env.VERCEL_TOKEN != ''
        run: |
          echo "Deploying to Vercel..."
          echo "url=https://foodable.vercel.app" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Deploy to Netlify (if configured)
        if: env.NETLIFY_AUTH_TOKEN != ''
        uses: netlify/actions/cli@master
        with:
          args: deploy --dir=frontend/dist --prod=${{ needs.prepare.outputs.environment == 'production' }}
        env:
          NETLIFY_AUTH_TOKEN: ${{ env.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ env.NETLIFY_SITE_ID }}
        continue-on-error: true

      - name: Deploy to GitHub Pages (if main branch)
        if: github.ref == 'refs/heads/main' && needs.prepare.outputs.environment == 'production'
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./frontend/dist
          cname: foodable.example.com
        continue-on-error: true

      - name: Deployment success notification
        run: |
          echo "‚úÖ Frontend deployed to ${{ needs.prepare.outputs.environment }}"
          echo "Version: ${{ needs.prepare.outputs.version }}"

  deploy-backend:
    name: Deploy Backend to ${{ needs.prepare.outputs.environment }}
    needs: [prepare, build-backend]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: ${{ needs.prepare.outputs.environment }}-backend
      url: ${{ steps.deploy.outputs.url }}
    env:
      HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
      RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    steps:
      - name: Download backend build
        uses: actions/download-artifact@v7
        with:
          name: backend-build
          path: backend

      - name: Deploy to Heroku (if configured)
        id: deploy
        if: env.HEROKU_API_KEY != ''
        uses: akhileshns/heroku-deploy@v3.14.15
        with:
          heroku_api_key: ${{ env.HEROKU_API_KEY }}
          heroku_app_name: ${{ secrets.HEROKU_APP_NAME }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          appdir: backend
        env:
          HD_NODE_ENV: production
          HD_JWT_SECRET: ${{ secrets.JWT_SECRET }}
          HD_DB_HOST: ${{ secrets.DB_HOST }}
          HD_DB_USER: ${{ secrets.DB_USER }}
          HD_DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          HD_DB_NAME: ${{ secrets.DB_NAME }}
        continue-on-error: true

      - name: Deploy to Railway (if configured)
        if: env.RAILWAY_TOKEN != ''
        run: |
          echo "Deploying to Railway..."
          # Railway deployment would go here
        continue-on-error: true

      - name: Deploy via SSH (if configured)
        if: env.SSH_PRIVATE_KEY != ''
        uses: appleboy/ssh-action@v1.2.5
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script: |
            cd /var/www/foodable-backend
            git pull origin main
            npm install --production
            npm run build
            pm2 restart foodable-api
        continue-on-error: true

      - name: Deployment success notification
        run: |
          echo "‚úÖ Backend deployed to ${{ needs.prepare.outputs.environment }}"
          echo "Version: ${{ needs.prepare.outputs.version }}"

  post-deploy:
    name: Post-Deployment Tasks
    needs: [prepare, deploy-frontend, deploy-backend]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: always()

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Health check
        run: |
          echo "Running health checks..."
          
          # Check backend health (if URL available)
          if [ -n "${{ secrets.BACKEND_URL }}" ]; then
            echo "Checking backend health..."
            curl -f ${{ secrets.BACKEND_URL }}/api/v1/health || echo "Backend health check failed"
          fi
          
          # Check frontend availability (if URL available)
          if [ -n "${{ secrets.FRONTEND_URL }}" ]; then
            echo "Checking frontend availability..."
            curl -f ${{ secrets.FRONTEND_URL }} || echo "Frontend check failed"
          fi

      - name: Send deployment notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Deployment to ${{ needs.prepare.outputs.environment }} ${{ job.status }}
            Version: ${{ needs.prepare.outputs.version }}
            Frontend: ${{ needs.deploy-frontend.result }}
            Backend: ${{ needs.deploy-backend.result }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        continue-on-error: true

      - name: Add deployment info to release
        if: needs.prepare.outputs.environment == 'production' && startsWith(needs.prepare.outputs.version, 'v')
        uses: actions/github-script@v8
        with:
          script: |
            // NOTE: Release is already created by semantic-release workflow
            // This only updates the existing release with deployment timestamp
            try {
              const { data: release } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: '${{ needs.prepare.outputs.version }}'
              });
              
              if (release && !release.body.includes('Deployed:')) {
                await github.rest.repos.updateRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id,
                  body: release.body + '\n\n---\n‚úÖ **Deployed to Production**: ' + new Date().toISOString()
                });
                console.log('‚úÖ Updated release with deployment timestamp');
              } else {
                console.log('Release already has deployment info or not found');
              }
            } catch (error) {
              console.log('Could not update release:', error.message);
            }
        continue-on-error: true

  rollback:
    name: Rollback on Failure
    needs: [prepare, deploy-frontend, deploy-backend]
    runs-on: ubuntu-latest
    if: failure()

    steps:
      - name: Rollback notification
        run: |
          echo "‚ùå Deployment failed - manual rollback may be required"
          echo "Environment: ${{ needs.prepare.outputs.environment }}"
          echo "Version: ${{ needs.prepare.outputs.version }}"

      - name: Create incident issue
        uses: actions/github-script@v8
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Deployment Failed - ${{ needs.prepare.outputs.environment }}',
              body: `Deployment to ${{ needs.prepare.outputs.environment }} failed.
              
              **Details:**
              - Version: ${{ needs.prepare.outputs.version }}
              - Workflow: ${context.workflow}
              - Run: ${context.runNumber}
              
              **Status:**
              - Frontend: ${{ needs.deploy-frontend.result }}
              - Backend: ${{ needs.deploy-backend.result }}
              
              Please investigate and rollback if necessary.`,
              labels: ['deployment', 'incident', 'high-priority']
            });
